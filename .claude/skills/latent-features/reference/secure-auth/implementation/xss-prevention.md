# XSS Prevention and Safe HTML Templates

**Purpose**: Cross-Site Scripting prevention through output encoding and safe HTML generation

**When to read**: During implementation of server-rendered HTML templates

**Source**: Full implementation in `docs/secure-authentication-guide.md` (lines 1735-1905)

---

## Threat Model

**XSS Attack**: Attacker injects malicious script into your HTML that executes in victim's browser

**Types**:

1. **Stored XSS**: Malicious script stored in database, displayed to all users
2. **Reflected XSS**: Malicious script in URL parameter, reflected in response
3. **DOM XSS**: Client-side JavaScript modifies DOM unsafely

**HTMX-specific risk**: Server responses are inserted directly into DOM, making output encoding critical

---

## Defense Strategy

**Primary defense**: **Output encoding** - Escape user data before including in HTML

**Secondary defenses**:

- Content Security Policy (CSP)
- HTMX `hx-disable` zones
- Safe template system with automatic encoding

---

## HTML Encoder

**File**: `src/infrastructure/security/HtmlEncoder.ts`

```typescript
export class HtmlEncoder {
  private static readonly ENCODE_MAP: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;',
  };

  /**
   * Encode for HTML content (between tags)
   */
  static encodeForHtml(unsafe: string): string {
    return unsafe.replace(/[&<>"'/]/g, (char) => this.ENCODE_MAP[char] ?? char);
  }

  /**
   * Encode for HTML attributes
   */
  static encodeForAttribute(unsafe: string): string {
    return unsafe.replace(
      /[^a-zA-Z0-9,._-]/g,
      (char) => `&#x${char.charCodeAt(0).toString(16).padStart(2, '0')};`
    );
  }

  /**
   * Encode for JavaScript strings
   */
  static encodeForJavaScript(unsafe: string): string {
    return unsafe.replace(
      /[\\'\"<>&\u0000-\u001f\u007f-\u009f\u2028\u2029]/g,
      (char) => `\\u${char.charCodeAt(0).toString(16).padStart(4, '0')}`
    );
  }
}
```

**Context-specific encoding**:

- HTML content: `<div>${encoded}</div>`
- HTML attributes: `<div class="${encoded}">`
- JavaScript: `<script>const x = '${encoded}';</script>`
- URLs: Use `encodeURIComponent()` (built-in)

---

## Safe HTML Tagged Template

**File**: `src/presentation/templates/html.ts`

**Automatically encodes interpolated values**:

```typescript
export class SafeHtml {
  constructor(public readonly value: string) {}
  toString(): string {
    return this.value;
  }
}

export function safe(html: string): SafeHtml {
  return new SafeHtml(html);
}

export function html(
  strings: TemplateStringsArray,
  ...values: (Primitive | Primitive[] | SafeHtml)[]
): string {
  let result = strings[0] ?? '';

  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    const encoded = encodeValue(value);
    result += encoded + (strings[i + 1] ?? '');
  }

  return result;
}

function encodeValue(value: Primitive | Primitive[] | SafeHtml): string {
  if (value instanceof SafeHtml) {
    return value.value; // Already safe, don't encode
  }
  if (value === null || value === undefined) {
    return '';
  }
  if (Array.isArray(value)) {
    return value.map(encodeValue).join('');
  }
  if (typeof value === 'string') {
    return HtmlEncoder.encodeForHtml(value);
  }
  return HtmlEncoder.encodeForHtml(String(value));
}
```

---

## Safe Template Usage

**Automatic encoding** (default):

```typescript
export function renderUserProfile(user: User): string {
  // User data is automatically encoded
  return html`
    <div class="profile">
      <h2>${user.name}</h2>
      <p>${user.bio}</p>
      <a href="/users/${user.id}">Profile</a>
    </div>
  `;
}
```

**Input**: `user.name = "<script>alert('XSS')</script>"`

**Output**:

```html
<div class="profile">
  <h2>&lt;script&gt;alert('XSS')&lt;/script&gt;</h2>
  ...
</div>
```

**Marking content as safe** (use with extreme caution):

```typescript
export function renderMarkdown(content: string): string {
  // Parse markdown to HTML using trusted library
  const trustedHtml = marked.parse(content);

  // Mark as safe to prevent double-encoding
  return html` <div class="markdown-content">${safe(trustedHtml)}</div> `;
}
```

**When to use `safe()`**:

- Content from trusted markdown/wiki parser
- HTML generated by your own trusted functions
- Content already validated/sanitized

**When NOT to use `safe()`**:

- Direct user input (always encode)
- Content from external sources
- Uncertain provenance

---

## HTMX-Specific Protection

### hx-disable Attribute

**Creates safe zone where HTMX attributes are ignored**:

```typescript
export function renderComment(comment: Comment): string {
  // User-provided content in hx-disable zone
  return html`
    <div class="comment" hx-disable>
      <p class="author">${comment.authorName}</p>
      <div class="content">${comment.content}</div>
    </div>
  `;
}
```

**Why this matters**:

- Prevents users from injecting malicious HTMX attributes
- Example attack: `<div hx-get="/admin/delete-all" hx-trigger="load">`
- `hx-disable` makes all HTMX attributes inert within zone

### HTMX Configuration

**Meta tag** in base layout:

```html
<meta
  name="htmx-config"
  content='{
  "selfRequestsOnly": true,
  "allowScriptTags": false,
  "allowEval": false,
  "historyCacheSize": 0
}'
/>
```

**Configuration explained**:

- `selfRequestsOnly: true` - Only same-origin requests allowed
- `allowScriptTags: false` - Prevents `<script>` execution in responses
- `allowEval: false` - Disables eval-based features
- `historyCacheSize: 0` - Prevents sensitive data caching

---

## Content Security Policy (CSP)

**Header configuration**:

```typescript
function securityHeaders(): Headers {
  const headers = new Headers();

  // Generate nonce for inline scripts
  const nonce = crypto.randomUUID();

  headers.set(
    'Content-Security-Policy',
    [
      "default-src 'self'",
      "script-src 'self' 'nonce-${nonce}'", // Only allow scripts with nonce
      "style-src 'self' 'unsafe-inline'", // Styles (consider nonce for production)
      "img-src 'self' data: https:", // Images
      "font-src 'self'", // Fonts
      "connect-src 'self'", // AJAX/fetch
      "frame-ancestors 'none'", // Clickjacking protection
      "base-uri 'self'", // Base tag restriction
      "form-action 'self'", // Form submission restriction
    ].join('; ')
  );

  headers.set('X-Content-Type-Options', 'nosniff');
  headers.set('X-Frame-Options', 'DENY');
  headers.set('X-XSS-Protection', '0'); // Disable legacy XSS filter

  return headers;
}
```

**Using nonces with inline scripts**:

```typescript
export function baseLayout(props: { title: string; content: string; nonce: string }): string {
  return html`
    <!DOCTYPE html>
    <html>
      <head>
        <title>${props.title}</title>
      </head>
      <body>
        ${safe(props.content)}

        <script src="/js/htmx.min.js" nonce="${props.nonce}"></script>
        <script nonce="${props.nonce}">
          // Inline scripts need nonce to execute
          htmx.config.selfRequestsOnly = true;
        </script>
      </body>
    </html>
  `;
}
```

---

## Attribute Safety

**URL attributes** (href, src):

```typescript
// Validate URLs before including
function isSafeUrl(url: string): boolean {
  try {
    const parsed = new URL(url, 'https://example.com');
    return ['http:', 'https:', 'mailto:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}

export function renderLink(href: string, text: string): string {
  if (!isSafeUrl(href)) {
    // Render as plain text instead
    return html`<span>${text}</span>`;
  }

  return html`<a href="${href}">${text}</a>`;
}
```

**Event handlers** (onclick, onerror):

- **Never** allow user input in event handler attributes
- Use addEventListener in separate `<script>` tags instead

```typescript
// BAD - User input in event handler
const bad = html`<button onclick="${userInput}">Click</button>`;

// GOOD - Event listener in script
const good = html`
  <button id="my-button">${buttonText}</button>
  <script nonce="${nonce}">
    document.getElementById('my-button').addEventListener('click', function () {
      // Safe handler code
    });
  </script>
`;
```

---

## Common XSS Vectors

### 1. Unencoded User Data

```typescript
// VULNERABLE
const vulnerable = `<div>${user.name}</div>`;

// SAFE
const safe = html`<div>${user.name}</div>`;
```

### 2. Dangerous Contexts

```typescript
// VULNERABLE - User data in script context
const vulnerable = html`<script>
  const name = '${user.name}';
</script>`;

// SAFE - JavaScript encoding
const safe = html`<script>
  const name = '${HtmlEncoder.encodeForJavaScript(user.name)}';
</script>`;
```

### 3. URL Injection

```typescript
// VULNERABLE
const vulnerable = html`<a href="${user.website}">Profile</a>`;
// User input: "javascript:alert('XSS')"

// SAFE - Validate protocol
function renderLink(url: string): string {
  if (!isSafeUrl(url)) {
    return html`<span>Invalid URL</span>`;
  }
  return html`<a href="${url}">Profile</a>`;
}
```

### 4. HTML Injection

```typescript
// VULNERABLE - Allowing raw HTML
const vulnerable = html`<div>${safe(user.bio)}</div>`;

// SAFE - Always encode unless explicitly sanitized
const safe = html`<div>${user.bio}</div>`;

// SAFE - Use trusted sanitizer for rich text
import DOMPurify from 'dompurify';
const sanitized = DOMPurify.sanitize(user.bio);
const safe = html`<div>${safe(sanitized)}</div>`;
```

---

## Testing Strategy

```typescript
describe('XSS Prevention', () => {
  it('should encode HTML in template values', () => {
    const malicious = '<script>alert("XSS")</script>';
    const result = html`<div>${malicious}</div>`;

    expect(result).toBe('<div>&lt;script&gt;alert("XSS")&lt;/script&gt;</div>');
    expect(result).not.toContain('<script>');
  });

  it('should preserve safe HTML', () => {
    const trusted = safe('<strong>Bold</strong>');
    const result = html`<div>${trusted}</div>`;

    expect(result).toBe('<div><strong>Bold</strong></div>');
  });

  it('should reject javascript: URLs', () => {
    const maliciousUrl = 'javascript:alert("XSS")';

    expect(isSafeUrl(maliciousUrl)).toBe(false);
  });

  it('should disable HTMX in user content zones', () => {
    const malicious = '<div hx-get="/admin/delete" hx-trigger="load">';
    const result = html`<div hx-disable>${malicious}</div>`;

    // HTMX attributes inside hx-disable are ignored
    // (verify via E2E test that HTMX doesn't execute)
  });
});
```

---

## Security Checklist

- [ ] All user input is encoded before output
- [ ] Safe template system (`html```) used consistently
- [ ] `safe()` only used for trusted, sanitized content
- [ ] HTMX configured with `allowScriptTags: false`
- [ ] User content areas wrapped in `hx-disable`
- [ ] CSP header configured with nonces
- [ ] URL validation for href/src attributes
- [ ] No user input in event handlers (onclick, etc.)
- [ ] DOMPurify or similar for rich text sanitization

---

## Next Steps

- For HTMX security configuration → Read full guide sections on HTMX and Alpine.js Security
- For complete template examples → Read full guide sections on Frontend Implementation
- For CSP configuration → Read full guide sections on Security Headers
