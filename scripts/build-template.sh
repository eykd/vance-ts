#!/usr/bin/env bash
# build-template.sh - Package repository into a single .tmplr template file
#
# This script creates a tmplr-format template file from the repository,
# using the txtar-inspired format with {### FILE path ###} headers.
#
# Usage: ./scripts/build-template.sh
# Output: dist/template.tmplr

set -euo pipefail

# Configuration
readonly OUTPUT_DIR="dist"
readonly OUTPUT_FILE="${OUTPUT_DIR}/template.tmplr"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Hardcoded exclusions (in addition to .gitignore)
readonly EXCLUSIONS=(
    ".git/"
    ".beads/"
    "specs/"
    "thoughts/"
)

# Statistics
files_processed=0
dirs_excluded=0
files_excluded=0

# Print error message and exit
error() {
    echo "Error: $1" >&2
    exit 1
}

# Print progress message
info() {
    echo "$1"
}

# Check if path should be excluded
is_excluded() {
    local path="$1"

    for exclusion in "${EXCLUSIONS[@]}"; do
        # Check if path starts with exclusion pattern (directory)
        if [[ "$path" == "${exclusion}"* ]] || [[ "$path" == "${exclusion%/}"* ]]; then
            return 0
        fi
    done

    return 1
}

# Validate we're in a git repository
validate_repository() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        error "Not inside a git repository"
    fi

    # Get the actual repo root from git
    local git_root
    git_root="$(git rev-parse --show-toplevel)"

    if [[ "$git_root" != "$REPO_ROOT" ]]; then
        error "Script must be run from repository root. Expected: $REPO_ROOT, Got: $git_root"
    fi
}

# Create output directory if it doesn't exist (FR-013)
ensure_output_dir() {
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
        info "Created output directory: $OUTPUT_DIR"
    fi
}

# Get list of files to include in template
# Uses git ls-files to respect .gitignore (FR-003)
get_files() {
    git ls-files --cached --others --exclude-standard | while read -r file; do
        # Skip excluded directories (FR-004 through FR-007)
        if is_excluded "$file"; then
            ((files_excluded++)) || true
            continue
        fi

        # Skip if file doesn't exist (deleted but still tracked)
        if [[ -f "$file" ]]; then
            echo "$file"
        fi
    done
}

# Transform package.json content to use app_name variable (FR-012)
transform_package_json() {
    local content="$1"
    # Replace the name field value with {{ app_name }}
    echo "$content" | sed 's/"name": "[^"]*"/"name": "{{ app_name }}"/'
}

# Generate wrangler.toml content (FR-008 through FR-010)
generate_wrangler_toml() {
    cat << 'EOF'
name = "{{ app_name }}"
pages_build_output_dir = "hugo/public"

# Uncomment and configure bindings as needed:
#
# [[d1_databases]]
# binding = "DB"
# database_name = "my-database"
# database_id = "your-database-id"
#
# [[kv_namespaces]]
# binding = "KV"
# id = "your-kv-namespace-id"
#
# [[r2_buckets]]
# binding = "R2"
# bucket_name = "my-bucket"
EOF
}

# Required scaffold directories (excluded from git but needed for tests)
readonly SCAFFOLD_DIRS=(
    "thoughts/handoffs"
    "thoughts/ledgers"
)

# Write a file section to the template (FR-011)
write_file_section() {
    local path="$1"
    local content="$2"

    echo "{### FILE ${path} ###}"
    echo "$content"
    echo ""
}

# Main build function
build_template() {
    info "Building template..."

    # Clear/create output file
    > "$OUTPUT_FILE"

    # Add template preamble (comment section)
    cat >> "$OUTPUT_FILE" << 'EOF'
# turtlebased-ts template
# Generated by build-template.sh
# Use with: tmplr make template.tmplr <output-dir> app_name=<your-app-name>

EOF

    # Add wrangler.toml (generated, not from source) (FR-008)
    local wrangler_content
    wrangler_content="$(generate_wrangler_toml)"
    write_file_section "wrangler.toml" "$wrangler_content" >> "$OUTPUT_FILE"
    ((files_processed++)) || true

    # Add scaffold directories with .gitkeep (excluded dirs that need to exist)
    for dir in "${SCAFFOLD_DIRS[@]}"; do
        write_file_section "${dir}/.gitkeep" "" >> "$OUTPUT_FILE"
        ((files_processed++)) || true
    done

    # Process each file from the repository
    while IFS= read -r file; do
        local content

        # Special handling for package.json (FR-012)
        if [[ "$file" == "package.json" ]]; then
            content="$(transform_package_json "$(cat "$file")")"
        else
            content="$(cat "$file")"
        fi

        write_file_section "$file" "$content" >> "$OUTPUT_FILE"
        ((files_processed++)) || true
    done < <(get_files)

    # Count excluded directories
    dirs_excluded="${#EXCLUSIONS[@]}"
}

# Print summary (FR-017)
print_summary() {
    local output_path
    output_path="$(cd "$REPO_ROOT" && pwd)/${OUTPUT_FILE}"

    info "Processed: ${files_processed} files"
    info "Excluded: ${dirs_excluded} directories, ${files_excluded} files (gitignore)"
    info "Output: ${output_path}"
}

# Main entry point
main() {
    cd "$REPO_ROOT"

    validate_repository
    ensure_output_dir
    build_template
    print_summary

    info "Template build complete!"
}

main "$@"
